Index: client_files/code/world.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from collections import deque\r\nimport random\r\n\r\nimport pygame\r\nfrom typing import Dict\r\nfrom client_files.code.settings import *\r\nfrom client_files.code.tile import Tile\r\nfrom client_files.code.player import Player\r\nfrom client_files.code.support import *\r\nfrom client_files.code.weapon import Weapon\r\nfrom client_files.code.enemy import Enemy\r\nfrom client_files.code.projectile import Projectile\r\nfrom client_files.code.ui import UI\r\nfrom client_files.code.structures import *\r\n\r\n\r\nclass World:\r\n    def __init__(self) -> None:\r\n        # Pygame window\r\n        self.display_surface: pygame.Surface = pygame.display.get_surface()\r\n\r\n        # Visible sprites: sprites that show on screen\r\n        # Obstacle sprites: sprite the player can collide with\r\n        # Server sprites: sprites whose updates have to be sent to the server\r\n        self.visible_sprites: GroupYSort = GroupYSort()\r\n        self.obstacle_sprites: pygame.sprite.Group = pygame.sprite.Group()\r\n        self.server_sprites: pygame.sprite.Group = pygame.sprite.Group()\r\n        self.projectile_sprites: pygame.sprite.Group = pygame.sprite.Group()\r\n\r\n        # User interface\r\n        self.ui = UI()\r\n\r\n        # attack sprites\r\n        self.current_weapon = None\r\n\r\n        # Calculate screen center\r\n        self.half_width: int = self.display_surface.get_size()[0] // 2\r\n        self.half_height: int = self.display_surface.get_size()[1] // 2\r\n        self.screen_center: pygame.math.Vector2 = pygame.math.Vector2(self.half_width, self.half_height)\r\n\r\n        # Camera position for drawing offset\r\n        self.camera: pygame.math.Vector2 = pygame.math.Vector2()\r\n\r\n        # Player before creation\r\n        self.player: Player = None\r\n\r\n        # enemies dict\r\n        self.enemies: Dict[int, Enemy] = {}  # entity_id : Enemy\r\n\r\n        # All layout csv files of the map\r\n        self.layout: dict[str: list[list[int]]] = {\r\n            'floor': import_csv_layout('../graphics/map/map_Ground.csv'),\r\n            'objects': import_csv_layout('../graphics/map/map_Objects.csv'),\r\n            'boundary': import_csv_layout('../graphics/map/map_Barriers.csv'),\r\n        }\r\n\r\n        # All graphics groups\r\n        self.graphics: dict[str: dict[int: pygame.Surface]] = {\r\n            'floor': import_folder('../graphics/tiles'),\r\n            'objects': import_folder('../graphics/objects')\r\n        }\r\n\r\n        # Load the map from settings.py\r\n        self.create_map()\r\n\r\n    def create_map(self) -> None:\r\n        \"\"\"\r\n        Place movable tiles on the map\r\n        :return: None\r\n        \"\"\"\r\n        # Create player with starting position\r\n        self.player = Player(self, (1024, 1024), [self.visible_sprites, self.server_sprites],\r\n                             self.obstacle_sprites, 1, 0)  # TODO - make starting player position random (or a spawn)\r\n\r\n        # Center camera\r\n        self.camera.x = self.player.rect.centerx\r\n        self.camera.y = self.player.rect.centery\r\n\r\n        # Spawn enemies\r\n        self.spawn_enemies(100)  # TODO: enemy count, spawn more if under 100\r\n\r\n    def run(self) -> Server.Output.StateUpdate:\r\n        \"\"\"\r\n        Run one world frame\r\n        :return: None\r\n        \"\"\"\r\n\r\n        # Update the camera position\r\n        self.update_camera()\r\n\r\n        # Calculate played tile\r\n        player_tile: pygame.math.Vector2 = pygame.math.Vector2(int(self.player.rect.x / TILESIZE),\r\n                                                               int(self.player.rect.y / TILESIZE))\r\n\r\n        # Create and display all visible sprites\r\n        for style_index, (style, layout) in enumerate(self.layout.items()):\r\n            for row_index in range(int(player_tile.y - ROW_LOAD_TILE_DISTANCE),\r\n                                   int(player_tile.y + ROW_LOAD_TILE_DISTANCE)):\r\n                if 0 <= row_index < ROW_TILES:\r\n                    row = layout[row_index]\r\n                    for col_index in range(int(player_tile.x - COL_LOAD_TILE_DISTANCE),\r\n                                           int(player_tile.x + COL_LOAD_TILE_DISTANCE)):\r\n                        if 0 <= col_index < COL_TILES:\r\n                            col = row[col_index]\r\n                            if col != '-1':  # -1 in csv means no tile, don't need to recreate the tile if it already exists\r\n                                x: int = col_index * TILESIZE\r\n                                y: int = row_index * TILESIZE\r\n\r\n                                if style == 'floor':\r\n                                    surface: pygame.Surface = self.graphics['floor'][col]\r\n                                    Tile((x, y), [self.visible_sprites], 'floor', col in SPAWNABLE_TILES, 0, surface)\r\n                                elif style == 'objects':\r\n                                    surface: pygame.Surface = self.graphics['objects'][col]\r\n                                    Tile((x, y), (self.visible_sprites, self.obstacle_sprites), 'object', False, 1,\r\n                                         surface)\r\n                                elif style == 'boundary':\r\n                                    Tile((x, y), [self.obstacle_sprites], 'barrier', False)\r\n\r\n        # Display all visible sprites\r\n        self.visible_sprites.custom_draw(self.camera, self.screen_center)\r\n\r\n        # Update the obstacle sprites for the player\r\n        self.player.update_obstacles(self.obstacle_sprites)\r\n        for projectile in self.projectile_sprites:\r\n            projectile.update_obstacles(self.obstacle_sprites)\r\n\r\n        # Run update() function in all visible sprites' classes\r\n        self.visible_sprites.update()\r\n\r\n        # Delete all tiles\r\n        for sprite in self.visible_sprites.sprites() + self.obstacle_sprites.sprites():\r\n            if type(sprite) is Tile:\r\n                sprite.kill()\r\n\r\n        self.ui.display(self.player)\r\n\r\n        local_changes = [[], [], []]  # A list of changes made in this tick. 0 - player, 1 - enemies, 2 - items.\r\n        for sprite in self.server_sprites.sprites():\r\n            if sprite.changes is None:  # If no new changes were made\r\n                continue\r\n            if type(sprite) is Player:\r\n                local_changes[0].append(Server.Output.PlayerUpdate(id=sprite.entity_id, changes=sprite.changes))\r\n            elif type(sprite) is Enemy:\r\n                pass  # append EnemyUpdate to local_changes[1]\r\n\r\n        return Server.Output.StateUpdate(changes=local_changes)\r\n\r\n\r\n    def update_camera(self) -> None:\r\n        \"\"\"\r\n        update the camera position\r\n        :return: None\r\n        \"\"\"\r\n        # Figure out offset based on camera position\r\n\r\n        # X axis\r\n        if abs(self.player.rect.centerx - self.camera.x) > CAMERA_DISTANCE_FROM_PLAYER[\r\n            0]:  # If the camera is too far from the player\r\n            if self.player.rect.centerx > self.camera.x:  # Move the camera from to the left of the bound if it's further left than the player\r\n                self.camera.x = self.player.rect.centerx - CAMERA_DISTANCE_FROM_PLAYER[0]\r\n            else:  # Move the camera from to the right of the bound if it's further right than the player\r\n                self.camera.x = self.player.rect.centerx + CAMERA_DISTANCE_FROM_PLAYER[0]\r\n\r\n        # Y axis\r\n        if abs(self.player.rect.centery - self.camera.y) > CAMERA_DISTANCE_FROM_PLAYER[\r\n            1]:  # If the camera is too far from the player\r\n            if self.player.rect.centery > self.camera.y:  # Move the camera from to the top of the bound if it's further up than the player\r\n                self.camera.y = self.player.rect.centery - CAMERA_DISTANCE_FROM_PLAYER[1]\r\n            else:  # Move the camera from to the bottom of the bound if it's further down than the player\r\n                self.camera.y = self.player.rect.centery + CAMERA_DISTANCE_FROM_PLAYER[1]\r\n\r\n    def spawn_enemies(self,\r\n                      amount: int) -> None:  # TODO: should be random, dont spawn on water/player, collidable block\r\n\r\n        for enemy in range(amount):\r\n            random_x = random.randint(0, 1280 * 40 // 64 - 1)\r\n            random_y = random.randint(0, 720 * 40 // 64 - 1)\r\n            name = list(enemy_data.keys())[int(random.randint(0, 3))]\r\n\r\n            if int(self.layout['floor'][random_y][random_x]) in SPAWNABLE_TILES:\r\n                Enemy(world=self, enemy_name=name, pos=(random_x * 64, random_y * 64),\r\n                      groups=[self.visible_sprites, self.obstacle_sprites],\r\n                      entity_id=None)  # TODO: @gognl whats # entity id?\r\n\r\n\r\nclass GroupYSort(pygame.sprite.Group):\r\n    def __init__(self) -> None:\r\n        super().__init__()\r\n        self.display_surface = pygame.display.get_surface()\r\n\r\n    def custom_draw(self, camera: pygame.math.Vector2, screen_center: pygame.math.Vector2) -> None:\r\n        \"\"\"\r\n        Draws the sprites on screen according to the screen height, and then according to the position of the camera\r\n        :return: None\r\n        \"\"\"\r\n        # For every visible sprite, from top to bottom\r\n        for sprite in sorted(self.sprites(), key=lambda x: (x.height, x.rect.centery)):\r\n            # Display the sprite on screen, moving it by the calculated offset\r\n            self.display_surface.blit(sprite.image, sprite.rect.topleft - camera + screen_center)\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/client_files/code/world.py b/client_files/code/world.py
--- a/client_files/code/world.py	(revision 37c997a43141761bc8822d71736f00dff837a247)
+++ b/client_files/code/world.py	(date 1675678929983)
@@ -145,7 +145,6 @@
 
         return Server.Output.StateUpdate(changes=local_changes)
 
-
     def update_camera(self) -> None:
         """
         update the camera position
@@ -179,8 +178,7 @@
 
             if int(self.layout['floor'][random_y][random_x]) in SPAWNABLE_TILES:
                 Enemy(world=self, enemy_name=name, pos=(random_x * 64, random_y * 64),
-                      groups=[self.visible_sprites, self.obstacle_sprites],
-                      entity_id=None)  # TODO: @gognl whats # entity id?
+                      groups=(self.visible_sprites, self.obstacle_sprites), entity_id=1)
 
 
 class GroupYSort(pygame.sprite.Group):
Index: client_files/code/main.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import socket  # Socket\r\nimport pygame  # Pygame\r\nfrom threading import Thread  # Multi-threading\r\nfrom queue import Queue, Empty  # Multi-threaded sorted queue\r\nfrom collections import deque  # Normal queue\r\nfrom client_files.code.structures import *\r\nfrom client_files.code.settings import *\r\nfrom client_files.code.world import World\r\nfrom client_files.code.enemy import Enemy\r\n\r\n\r\ndef initialize_connection(server_addr: (str, int)) -> (socket.socket, Queue, int):\r\n    \"\"\"\r\n    Initializes the connection to the server, and starts the packets-handler thread.\r\n    :param server_addr: The address of the server.\r\n    :return: A tuple containing the server socket, updates queue and the id of the client.\r\n    \"\"\"\r\n\r\n    # Create the socket - TODO\r\n    server_socket: socket.socket = socket.socket()  # CHANGE LATER - TODO\r\n    server_socket.connect(server_addr)\r\n\r\n    # Establish some synchronization stuff - TODO\r\n    client_id: int = int(server_socket.recv(5)[3:])  # id_<2 bytes>\r\n    print(f'client {client_id} connected')\r\n\r\n    # Start the packets-handler thread & initialize the queue\r\n    updates_queue: Queue = Queue()\r\n    pkts_handler: Thread = Thread(target=handle_server_pkts, args=(server_socket, updates_queue))\r\n    pkts_handler.start()\r\n\r\n    return server_socket, updates_queue, client_id\r\n\r\ndef send_msg_to_server(server_socket: socket.socket, msg: Server.Output.StateUpdate):\r\n    \"\"\"Sends a message to the server (and encrypts it)\"\"\"\r\n    data: bytes = msg.serialize()\r\n    # TODO encrypt here\r\n    server_socket.send(data)\r\n\r\n\r\ndef get_server_pkt(server_socket: socket.socket) -> bytes:  # TODO\r\n    \"\"\"\r\n    Gets a packet from the server (and decrypts them...)\r\n    :return: The packet from the server.\r\n    \"\"\"\r\n    data: bytes = server_socket.recv(1024)\r\n    # TODO decrypt here\r\n    return data\r\n\r\n\r\ndef handle_server_pkts(server_socket: socket.socket, updates_queue: Queue) -> None:\r\n    \"\"\"\r\n    Handles the packets which are received from the server, and adds them to the updates priority queue.\r\n    :return: None\r\n    \"\"\"\r\n    while True:\r\n        # Get a packet from the server; convert it to a ServerMessage object.\r\n        msg: Server.Input.StateUpdate = Server.Input.StateUpdate(ser=get_server_pkt(server_socket))\r\n        updates_queue.put(msg)\r\n\r\n\r\ndef update_game(update_msg: Server.Input.StateUpdate, changes: deque[Server.Output.StateUpdate], client_id: int, world: World) -> None:\r\n    \"\"\"\r\n    Updates the game according to the update from the server, and the changes made with the inputs received before the updated state.\r\n    :param world: The pygame world.\r\n    :param client_id: The id of this client.\r\n    :param update_msg: The update message from the server.\r\n    :param changes: A queue of the changes made to the game since the last call to this function.\r\n    :return: None\r\n    \"\"\"\r\n\r\n    # Update the game according to the update + changes since its ack (and remove them from the queue) - TODO\r\n\r\n    # Reset to the server state\r\n    for entity_update in update_msg.state_update.changes:\r\n        entity_id: int = entity_update.id\r\n        entity_pos: (int, int) = entity_update.pos\r\n        entity_status: str = entity_update.status\r\n\r\n        if entity_id == client_id:\r\n            world.player.rect.x = entity_pos[0]\r\n            world.player.rect.y = entity_pos[1]\r\n            world.player.status = entity_status\r\n            world.player.animate()\r\n        elif entity_id in world.enemies:\r\n            world.enemies[entity_id].status = entity_status\r\n            world.enemies[entity_id].animate()\r\n            world.enemies[entity_id].update_pos(entity_pos)\r\n        else:\r\n            world.enemies[entity_id] = Enemy('other_player', entity_pos, [world.visible_sprites], entity_id)\r\n\r\n    # Clear the changes deque; Leave only the changes made after the acknowledged CMD\r\n    while changes and changes[0].seq < update_msg.ack:\r\n        changes.popleft()\r\n\r\n    # Apply the changes - TODO simulate, dont just change attributes\r\n    for cmd in changes:\r\n        for player_change in cmd.player_changes:\r\n            world.player.rect.x = player_change.pos[0]\r\n            world.player.rect.y = player_change.pos[1]\r\n            world.player.attacking = player_change.attacking\r\n            world.player.weapon = player_change.weapon\r\n            world.player.status = player_change.status\r\n        # TODO also update enemies and items (cmd.enemies_changes, cmd.items_changes)\r\n\r\n\r\ndef initialize_game() -> (pygame.Surface, pygame.time.Clock, World):\r\n    \"\"\"\r\n    Initializes the game.\r\n    :return: screen, clock\r\n    \"\"\"\r\n    pygame.init()\r\n    f = (SCREEN_WIDTH, SCREEN_HEIGHT)\r\n    screen = pygame.display.set_mode(f)\r\n    pygame.display.set_caption(\"Cows\")\r\n    clock = pygame.time.Clock()\r\n    world = World()\r\n\r\n    return screen, clock, world\r\n\r\n\r\ndef game_tick(screen: pygame.Surface, clock: pygame.time.Clock, world: World) -> (pygame.Surface, pygame.time.Clock, World, Server.Output.StateUpdate):\r\n    \"\"\"\r\n    Run game according to user inputs - prediction before getting update from server\r\n    :return: updated screen, clock, and world\r\n    \"\"\"\r\n\r\n    # Reset screen to black - delete last frame from screen\r\n    screen.fill('black')\r\n\r\n    # Update the world state and then the screen\r\n    update: Server.Output.StateUpdate = world.run()\r\n    pygame.display.update()\r\n\r\n    # Wait for one tick\r\n    clock.tick(FPS)\r\n\r\n    return screen, clock, world, update\r\n\r\n\r\ndef run_game(*args) -> None:  # TODO\r\n    \"\"\"\r\n    Runs the game.\r\n    :return: None\r\n    \"\"\"\r\n\r\n    # Check for invalid number of arguments; Should be okay to delete this in the final version - TODO\r\n    if len(args) != 6:\r\n        print('you did smth wrong smh')\r\n        return\r\n\r\n    # Unpack the arguments\r\n    server_socket: socket.socket = args[0]\r\n    screen: pygame.Surface = args[1]\r\n    clock: pygame.time.Clock = args[2]\r\n    world: World = args[3]\r\n    update_queue: Queue = args[4]\r\n    client_id: int = args[5]\r\n\r\n    # Create custom events\r\n    update_required_event = pygame.USEREVENT + 1\r\n\r\n    # The changes queue; Push to it data about the changes after every cmd sent to the server\r\n    reported_changes: deque[Server.Output.StateUpdate] = deque()\r\n\r\n    # The main game loop\r\n    running: bool = True\r\n    while running:\r\n        for event in pygame.event.get():\r\n            if event.type == update_required_event:\r\n                update_game(event.msg, reported_changes, client_id, world)\r\n            elif event.type == pygame.QUIT:\r\n                running = False\r\n            elif event.type == pygame.KEYDOWN:\r\n                if event.key == pygame.K_RETURN:\r\n                    running = False\r\n\r\n        # Run game according to user inputs - prediction before getting update from server\r\n        tick_update: Server.Output.StateUpdate\r\n        screen, clock, world, tick_update = game_tick(screen, clock, world)\r\n\r\n        if tick_update.player_changes:\r\n            send_msg_to_server(server_socket, tick_update)\r\n            reported_changes.append(tick_update)\r\n            Server.Output.StateUpdate.seq_count += 1\r\n\r\n        # Check if an update is needed\r\n        if not update_queue.empty():\r\n\r\n            # Get the message from the queue\r\n            try:\r\n                update_msg: Server.Input.StateUpdate = update_queue.get_nowait()\r\n            except Empty:\r\n                continue\r\n\r\n            # Post the event\r\n            pygame.event.post(pygame.event.Event(update_required_event, {\"msg\": update_msg}))\r\n\r\n    pygame.quit()\r\n\r\n\r\ndef close_game(server_socket: socket.socket) -> None:\r\n    \"\"\"Closes the game\"\"\"\r\n    server_socket.close()\r\n\r\n\r\ndef main():\r\n    server_addr: (str, int) = ('127.0.0.1', 34863)  # TEMPORARY\r\n\r\n    # Initialize the game\r\n    screen, clock, world = initialize_game()\r\n\r\n    # Initialize the connection with the server\r\n    server_socket: socket.socket\r\n    updates_queue: Queue\r\n    client_id: int\r\n    server_socket, updates_queue, client_id = initialize_connection(server_addr)\r\n    world.player.entity_id = client_id\r\n\r\n    # Run the main game\r\n    run_game(server_socket, screen, clock, world, updates_queue, client_id)\r\n\r\n    # Close the game\r\n    close_game(server_socket)\r\n\r\n\r\nif __name__ == '__main__':\r\n    main()\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/client_files/code/main.py b/client_files/code/main.py
--- a/client_files/code/main.py	(revision 37c997a43141761bc8822d71736f00dff837a247)
+++ b/client_files/code/main.py	(date 1675678929981)
@@ -31,6 +31,7 @@
 
     return server_socket, updates_queue, client_id
 
+
 def send_msg_to_server(server_socket: socket.socket, msg: Server.Output.StateUpdate):
     """Sends a message to the server (and encrypts it)"""
     data: bytes = msg.serialize()
@@ -205,7 +206,7 @@
 
 
 def main():
-    server_addr: (str, int) = ('127.0.0.1', 34863)  # TEMPORARY
+    server_addr: (str, int) = ('127.0.0.1', 34860)  # TEMPORARY
 
     # Initialize the game
     screen, clock, world = initialize_game()
Index: server_files_normal/main.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/server_files_normal/main.py b/server_files_normal/server_main.py
rename from server_files_normal/main.py
rename to server_files_normal/server_main.py
--- a/server_files_normal/main.py	(revision 37c997a43141761bc8822d71736f00dff837a247)
+++ b/server_files_normal/server_main.py	
@@ -72,7 +72,7 @@
 	login_sock, lb_manager = initialize_connection(login_addr, lb_addr)
 
 	server_sock: socket.socket = socket.socket()
-	server_sock.bind(('0.0.0.0', 34863))
+	server_sock.bind(('0.0.0.0', 34860))
 	server_sock.listen()
 
 	client_managers: deque[ClientManager] = deque([])
Index: .idea/Mikmak-3.iml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<module type=\"PYTHON_MODULE\" version=\"4\">\r\n  <component name=\"NewModuleRootManager\">\r\n    <content url=\"file://$MODULE_DIR$\" />\r\n    <orderEntry type=\"jdk\" jdkName=\"Python 3.9\" jdkType=\"Python SDK\" />\r\n    <orderEntry type=\"sourceFolder\" forTests=\"false\" />\r\n  </component>\r\n  <component name=\"TestRunnerService\">\r\n    <option name=\"PROJECT_TEST_RUNNER\" value=\"Unittests\" />\r\n  </component>\r\n</module>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/Mikmak-3.iml b/.idea/Mikmak-3.iml
--- a/.idea/Mikmak-3.iml	(revision 37c997a43141761bc8822d71736f00dff837a247)
+++ b/.idea/Mikmak-3.iml	(date 1675678929977)
@@ -1,8 +1,10 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <module type="PYTHON_MODULE" version="4">
   <component name="NewModuleRootManager">
-    <content url="file://$MODULE_DIR$" />
-    <orderEntry type="jdk" jdkName="Python 3.9" jdkType="Python SDK" />
+    <content url="file://$MODULE_DIR$">
+      <excludeFolder url="file://$MODULE_DIR$/venv" />
+    </content>
+    <orderEntry type="inheritedJdk" />
     <orderEntry type="sourceFolder" forTests="false" />
   </component>
   <component name="TestRunnerService">
Index: .idea/misc.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"ProjectRootManager\" version=\"2\" project-jdk-name=\"Python 3.9\" project-jdk-type=\"Python SDK\" />\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/misc.xml b/.idea/misc.xml
--- a/.idea/misc.xml	(revision 37c997a43141761bc8822d71736f00dff837a247)
+++ b/.idea/misc.xml	(date 1675678929978)
@@ -1,4 +1,4 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <project version="4">
-  <component name="ProjectRootManager" version="2" project-jdk-name="Python 3.9" project-jdk-type="Python SDK" />
+  <component name="ProjectRootManager" version="2" project-jdk-name="Python 3.9 (Mikmak-3)" project-jdk-type="Python SDK" />
 </project>
\ No newline at end of file
